using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using System.Text.Json.Serialization;
using AIUsageTracker.Core.Interfaces;
using AIUsageTracker.Core.Models;
using Microsoft.Extensions.Logging;

namespace AIUsageTracker.Infrastructure.Providers;

public class MinimaxProvider : IProviderService
{
    public static ProviderDefinition StaticDefinition { get; } = new(
        providerId: "minimax",
        displayName: "MiniMax",
        planType: PlanType.Coding,
        isQuotaBased: true,
        defaultConfigType: "quota-based",
        logoKey: "minimax",
        includeInWellKnownProviders: true,
        handledProviderIds: new[] { "minimax-io", "minimax-global" });
        displayNameOverrides: new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["minimax-io"] = "Minimax (International)",
            ["minimax-global"] = "Minimax (International)"
        });

    public ProviderDefinition Definition => StaticDefinition;
    public string ProviderId => StaticDefinition.ProviderId;
    private readonly HttpClient _httpClient;
    private readonly ILogger<MinimaxProvider> _logger;

    public MinimaxProvider(HttpClient httpClient, ILogger<MinimaxProvider> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<IEnumerable<ProviderUsage>> GetUsageAsync(ProviderConfig config, Action<ProviderUsage>? progressCallback = null)
    {
        if (string.IsNullOrEmpty(config.ApiKey))
        {
            return new[] { new ProviderUsage
            {
                ProviderId = config.ProviderId,
                ProviderName = "Minimax",
                IsAvailable = false,
                IsQuotaBased = true,
                PlanType = PlanType.Coding,
                Description = "API Key not found."
            }};
        }

        string url;
        // Prioritize BaseUrl if set
        if (!string.IsNullOrEmpty(config.BaseUrl))
        {
            url = config.BaseUrl;
            if (!url.StartsWith("http")) url = "https://" + url;
        }
        else
        {
            // Determine endpoint based on ID suffix
            if (config.ProviderId.EndsWith("-io", StringComparison.OrdinalIgnoreCase) || 
                config.ProviderId.EndsWith("-global", StringComparison.OrdinalIgnoreCase))
            {
               url = "https://api.minimax.io/v1/user/usage";
            }
            else
            {
               url = "https://api.minimax.chat/v1/user/usage";
            }
        }

        var request = new HttpRequestMessage(HttpMethod.Get, url);
        request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", config.ApiKey);

        var response = await _httpClient.SendAsync(request);
        
        if (!response.IsSuccessStatusCode)
        {
            return new[] { new ProviderUsage
            {
                ProviderId = config.ProviderId,
                ProviderName = "Minimax",
                IsAvailable = false,
                IsQuotaBased = true,
                PlanType = PlanType.Coding,
                Description = $"API returned {response.StatusCode} for {url}"
            }};
        }

        var responseString = await response.Content.ReadAsStringAsync();
        
        double used = 0;
        double total = 0;

        try
        {
            var minimax = JsonSerializer.Deserialize<MinimaxResponse>(responseString);
            if (minimax?.Usage != null)
            {
                used = minimax.Usage.TokensUsed;
                total = minimax.Usage.TokensLimit > 0 ? minimax.Usage.TokensLimit : 0; 
            }
            else
            {
                 return new[] { new ProviderUsage
                 {
                     ProviderId = config.ProviderId,
                     ProviderName = "Minimax",
                     IsAvailable = false,
                     IsQuotaBased = true,
                     PlanType = PlanType.Coding,
                     Description = "Invalid Minimax response format"
                 }};
            }
        }
        catch (JsonException ex)
        {
            return new[] { new ProviderUsage
            {
                ProviderId = config.ProviderId,
                ProviderName = "Minimax",
                IsAvailable = false,
                IsQuotaBased = true,
                PlanType = PlanType.Coding,
                Description = $"Failed to parse Minimax response: {ex.Message}"
            }};
        }

        var utilization = total > 0 ? (used / total) * 100.0 : 0;

        return new[] { new ProviderUsage
        {
            ProviderId = config.ProviderId,
            ProviderName = "Minimax",
            RequestsPercentage = Math.Min(utilization, 100),
            RequestsUsed = used,
            RequestsAvailable = total,
            PlanType = PlanType.Coding,
            UsageUnit = "Tokens", 
            IsQuotaBased = true,
            Description = $"{used:N0} tokens used" + (total > 0 ? $" / {total:N0} limit" : "")
        }};
    }
    
    private class MinimaxResponse
    {
        [JsonPropertyName("usage")]
        public MinimaxUsage? Usage { get; set; }
    }
    
    private class MinimaxUsage
    {
        [JsonPropertyName("tokens_used")]
        public double TokensUsed { get; set; }
        
        [JsonPropertyName("tokens_limit")]
        public double TokensLimit { get; set; }
    }
}



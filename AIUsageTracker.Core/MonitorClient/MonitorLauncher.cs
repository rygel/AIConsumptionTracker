using System.Diagnostics;
using System.IO;
using System.Net.Http;
using System.Text.Json;
using AIUsageTracker.Core.Models;
using Microsoft.Extensions.Logging;

namespace AIUsageTracker.Core.MonitorClient;

public class MonitorLauncher
{
    private const int DefaultPort = 5000;
    private const int MaxWaitSeconds = 30;
    private const int StopWaitSeconds = 5;
    private static ILogger<MonitorLauncher>? _logger;
    private static readonly SemaphoreSlim StartupSemaphore = new(1, 1);

    public static void SetLogger(ILogger<MonitorLauncher> logger) => _logger = logger;


    private static async Task<MonitorInfo?> GetAgentInfoAsync()
    {
        try
        {
            var path = GetExistingAgentInfoPath();

            if (path != null)
            {
                var json = await File.ReadAllTextAsync(path).ConfigureAwait(false);
                return JsonSerializer.Deserialize<MonitorInfo>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
            }
            
            return null;
        }
        catch
        {
            return null;
        }
    }

    public static async Task<int> GetAgentPortAsync()
    {
        var info = await GetAndValidateMonitorInfoAsync().ConfigureAwait(false);
        return info?.Port > 0 ? info.Port : DefaultPort;
    }

    public static async Task<bool> IsAgentRunningAsync()
    {
        var info = await GetAndValidateMonitorInfoAsync().ConfigureAwait(false);
        if (info != null)
        {
            MonitorService.LogDiagnostic($"Monitor is running on port {info.Port}");
            return true;
        }

        var port = DefaultPort;
        MonitorService.LogDiagnostic($"Checking Monitor status on port: {port}");
        if (await CheckHealthAsync(port).ConfigureAwait(false))
        {
            MonitorService.LogDiagnostic($"Monitor is running on port {port}");
            return true;
        }

        MonitorService.LogDiagnostic($"Monitor not found on port {port}.");
        return false;
    }
    
    public static async Task<(bool isRunning, int port)> IsAgentRunningWithPortAsync()
    {
        var info = await GetAndValidateMonitorInfoAsync().ConfigureAwait(false);
        if (info != null)
        {
            return (true, info.Port);
        }

        var port = await GetAgentPortAsync().ConfigureAwait(false);
        MonitorService.LogDiagnostic($"Probing Monitor port: {port}");
        
        if (await CheckHealthAsync(port).ConfigureAwait(false))
        {
            return (true, port);
        }
        
        MonitorService.LogDiagnostic($"Monitor not found on port {port}.");
        return (false, port);
    }

    private static async Task<bool> CheckHealthAsync(int port)
    {
        try
        {
            using var client = new HttpClient { Timeout = TimeSpan.FromMilliseconds(500) };
            var response = await client.GetAsync($"http://localhost:{port}/api/health").ConfigureAwait(false);
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }

    private static Task<bool> CheckProcessRunningAsync(int processId)
    {
        if (processId <= 0) return Task.FromResult(false);
        try
        {
            var process = Process.GetProcessById(processId);
            return Task.FromResult(!process.HasExited);
        }
        catch (ArgumentException)
        {
            return Task.FromResult(false);
        }
        catch
        {
            return Task.FromResult(false);
        }
    }

    public static async Task<MonitorInfo?> GetAndValidateMonitorInfoAsync()
    {
        var info = await GetAgentInfoAsync().ConfigureAwait(false);
        if (info == null) return null;

        var port = info.Port;
        var processId = info.ProcessId;

        var healthOk = await CheckHealthAsync(port).ConfigureAwait(false);
        var processRunning = await CheckProcessRunningAsync(processId).ConfigureAwait(false);

        if (healthOk && processRunning)
        {
            return info;
        }

        MonitorService.LogDiagnostic($"Monitor metadata stale: health={healthOk}, processRunning={processRunning}, invalidating metadata");

        await InvalidateMonitorInfoAsync().ConfigureAwait(false);
        return null;
    }

    public static Task InvalidateMonitorInfoAsync()
    {
        try
        {
            foreach (var infoPath in GetExistingAgentInfoPaths())
            {
                var backupPath = infoPath + ".stale." + DateTimeOffset.UtcNow.ToUnixTimeSeconds();
                File.Move(infoPath, backupPath, overwrite: true);
                MonitorService.LogDiagnostic($"Backed up stale metadata to: {backupPath}");
            }
        }
        catch (Exception ex)
        {
            MonitorService.LogDiagnostic($"Failed to invalidate monitor metadata: {ex.Message}");
        }

        return Task.CompletedTask;
    }

    public static async Task<bool> StartAgentAsync()
    {
        await StartupSemaphore.WaitAsync().ConfigureAwait(false);
        try
        {
            var validatedInfo = await GetAndValidateMonitorInfoAsync().ConfigureAwait(false);
            if (validatedInfo != null)
            {
                MonitorService.LogDiagnostic($"Monitor already running on port {validatedInfo.Port}; skipping start.");
                return true;
            }

            // Get the port to use
            var port = await GetAgentPortAsync().ConfigureAwait(false);

            var monitorExeName = OperatingSystem.IsWindows()
                ? "AIUsageTracker.Monitor.exe"
                : "AIUsageTracker.Monitor";
            var legacyAgentExeName = OperatingSystem.IsWindows()
                ? "AIConsumptionTracker.Agent.exe"
                : "AIConsumptionTracker.Agent";
            
            // Try to find Agent executable
            var possiblePaths = new[]
            {
                // Development paths
                Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "AIUsageTracker.Monitor", "bin", "Debug", "net8.0", monitorExeName),
                Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "AIUsageTracker.Monitor", "bin", "Release", "net8.0", monitorExeName),
                // Legacy Windows-targeted development paths
                Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "AIUsageTracker.Monitor", "bin", "Debug", "net8.0-windows10.0.17763.0", "AIUsageTracker.Monitor.exe"),
                Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "AIUsageTracker.Monitor", "bin", "Release", "net8.0-windows10.0.17763.0", "AIUsageTracker.Monitor.exe"),
                // Installed paths
                Path.Combine(AppContext.BaseDirectory, monitorExeName),
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "AIUsageTracker", monitorExeName),
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "AIUsageTracker", monitorExeName),
                // Legacy compatibility
                Path.Combine(AppContext.BaseDirectory, legacyAgentExeName),
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "AIConsumptionTracker", monitorExeName),
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "AIConsumptionTracker", monitorExeName),
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "AIConsumptionTracker", legacyAgentExeName),
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "AIConsumptionTracker", legacyAgentExeName),
            };

            MonitorService.LogDiagnostic($"Locating Monitor executable (checked {possiblePaths.Length} common locations)...");
            var agentPath = possiblePaths.FirstOrDefault(File.Exists);

            if (agentPath == null)
            {
                MonitorService.LogDiagnostic("Monitor executable not found. Searching for project directory for 'dotnet run'...");
                // Try dotnet run in the Agent project directory
                var agentProjectDir = FindAgentProjectDirectory();
                if (agentProjectDir != null)
                {
                    MonitorService.LogDiagnostic($"Found Monitor project at: {agentProjectDir}. Launching via 'dotnet run'...");
                    var psi = new ProcessStartInfo
                    {
                        FileName = "dotnet",
                        Arguments = $"run --project \"{agentProjectDir}\" --urls \"http://localhost:{port}\" -- --debug",
                        UseShellExecute = false,
                        CreateNoWindow = true,
                        WindowStyle = ProcessWindowStyle.Hidden,
                        WorkingDirectory = agentProjectDir
                    };
                    
                    // Prevent MSBuild from leaving zombie processes that hold file locks
                    psi.Environment["MSBUILDDISABLENODEREUSE"] = "1";
                    psi.Environment["DOTNET_CLI_TELEMETRY_OPTOUT"] = "1";

                    Process.Start(psi);
                    return true;
                }

                MonitorService.LogDiagnostic("Could not find Monitor executable or project directory.");
                return false;
            }

            MonitorService.LogDiagnostic($"Monitor executable found at: {agentPath}. Launching...");
            var startInfo = new ProcessStartInfo
            {
                FileName = agentPath,
                Arguments = $"--urls \"http://localhost:{port}\" --debug",
                UseShellExecute = false,
                CreateNoWindow = true,
                WindowStyle = ProcessWindowStyle.Hidden,
                WorkingDirectory = Path.GetDirectoryName(agentPath)
            };

            Process.Start(startInfo);
            MonitorService.LogDiagnostic("Monitor process started.");
            return true;
        }
        catch (Exception ex)
        {
            MonitorService.LogDiagnostic($"Failed to start Monitor: {ex.Message}");
            return false;
        }
        finally
        {
            StartupSemaphore.Release();
        }
    }

    public static async Task<bool> StopAgentAsync()
    {
        try
        {
        var info = await GetAgentInfoAsync().ConfigureAwait(false);
            var targetPort = info?.Port > 0 ? info.Port : await GetAgentPortAsync().ConfigureAwait(false);
            if (info?.ProcessId > 0)
            {
                if (await TryStopProcessAsync(info.ProcessId).ConfigureAwait(false))
                {
                    return true;
                }
            }
            
            // Fallback: try to find and kill by process name
            var processes = Process.GetProcessesByName("AIUsageTracker.Monitor")
                .Concat(Process.GetProcessesByName("AIConsumptionTracker.Agent"))
                .ToArray();
            var stoppedAny = false;
            foreach (var process in processes)
            {
                using (process)
                {
                    if (await TryStopProcessAsync(process).ConfigureAwait(false))
                    {
                        stoppedAny = true;
                    }
                }
            }
            
            if (stoppedAny)
            {
                return true;
            }

            return !await CheckHealthAsync(targetPort).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to stop Agent");
            return false;
        }
    }

    private static async Task<bool> TryStopProcessAsync(int processId)
    {
        try
        {
            using var process = Process.GetProcessById(processId);
            return await TryStopProcessAsync(process).ConfigureAwait(false);
        }
        catch (ArgumentException)
        {
            return true;
        }
        catch (Exception ex)
        {
            MonitorService.LogDiagnostic($"Failed to stop process {processId}: {ex.Message}");
            return false;
        }
    }

    private static async Task<bool> TryStopProcessAsync(Process process)
    {
        try
        {
            if (process.HasExited)
            {
                return true;
            }

            process.Kill(entireProcessTree: true);
            await process.WaitForExitAsync().WaitAsync(TimeSpan.FromSeconds(StopWaitSeconds)).ConfigureAwait(false);
            return true;
        }
        catch (TimeoutException)
        {
            MonitorService.LogDiagnostic($"Timed out waiting for process {process.Id} to exit.");
            return process.HasExited;
        }
        catch (InvalidOperationException)
        {
            return true;
        }
        catch (Exception ex)
        {
            MonitorService.LogDiagnostic($"Failed to stop process {process.Id}: {ex.Message}");
            return false;
        }
    }

    public static async Task<bool> WaitForAgentAsync(CancellationToken cancellationToken = default)
    {
        MonitorService.LogDiagnostic($"Waiting for Monitor to start (max {MaxWaitSeconds}s)...");
        var startTime = DateTime.Now;
        int attempt = 0;
        while ((DateTime.Now - startTime).TotalSeconds < MaxWaitSeconds)
        {
            attempt++;
            var (isRunning, port) = await IsAgentRunningWithPortAsync().ConfigureAwait(false);
            if (isRunning)
            {
                MonitorService.LogDiagnostic($"Monitor is ready on port {port} after {(DateTime.Now - startTime).TotalSeconds:F1}s.");
                return true;
            }

            if (attempt % 5 == 0) // Log status every 1 second (5 * 200ms)
                MonitorService.LogDiagnostic($"Still waiting for Monitor... (elapsed: {(DateTime.Now - startTime).TotalSeconds:F1}s)");

            await Task.Delay(200, cancellationToken).ConfigureAwait(false);
        }
        MonitorService.LogDiagnostic("Timed out waiting for Monitor.");
        return false;
    }

    private static string? FindAgentProjectDirectory()
    {
        var currentDir = AppContext.BaseDirectory;
        for (int i = 0; i < 5; i++)
        {
            var agentDir = Path.Combine(currentDir, "AIUsageTracker.Monitor");
            if (Directory.Exists(agentDir) && File.Exists(Path.Combine(agentDir, "AIUsageTracker.Monitor.csproj")))
                return agentDir;

            var parent = Directory.GetParent(currentDir);
            if (parent == null) break;
            currentDir = parent.FullName;
        }

        // Try common locations
        var possibleRoots = new[]
        {
            Environment.CurrentDirectory,
            AppContext.BaseDirectory,
        };

        foreach (var root in possibleRoots)
        {
            if (!Directory.Exists(root)) continue;

            var agentDir = Path.Combine(root, "AIUsageTracker.Monitor");
            if (Directory.Exists(agentDir) && File.Exists(Path.Combine(agentDir, "AIUsageTracker.Monitor.csproj")))
                return agentDir;
        }

        return null;
    }

    private static string? GetExistingAgentInfoPath()
    {
        return GetExistingAgentInfoPaths().FirstOrDefault();
    }

    private static IEnumerable<string> GetExistingAgentInfoPaths()
    {
        return GetMonitorInfoCandidatePaths()
            .Where(File.Exists)
            .OrderByDescending(path => File.GetLastWriteTimeUtc(path));
    }

    private static IEnumerable<string> GetMonitorInfoCandidatePaths()
    {
        var appData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        return new[]
        {
            Path.Combine(appData, "AIUsageTracker", "monitor.json"),
            Path.Combine(appData, "AIUsageTracker", "Monitor", "monitor.json"),
            Path.Combine(appData, "AIUsageTracker", "Agent", "monitor.json"),
            Path.Combine(appData, "AIConsumptionTracker", "monitor.json"),
            Path.Combine(appData, "AIConsumptionTracker", "Monitor", "monitor.json"),
            Path.Combine(appData, "AIConsumptionTracker", "Agent", "monitor.json")
        };
    }
}


